using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using System.Linq;

public class PDMEvaluator : MonoBehaviour
{
    [Header("Setup")]
    public GameObject vlaAgentPrefab; // Prefab with AnchorClient_PDM
    public ZaraGroupRotationSimulator simulator;
    public float resetInterval = 0.8f;

    [Header("Map Generation")]
    public bool generateMap = true;
    public string mapFileName = "PDMTrajectoryMap.png";
    public int mapResolution = 2048;
    public float mapSize = 100f;
    public Color gtColor = Color.blue;
    public Color vlaColor = Color.red;
    public Color obstacleColor = new Color(1f, 0.5f, 0f); // Orange

    // Obstacles
    private Transform obstaclesRoot;
    private List<BoxCollider> obstacleColliders = new List<BoxCollider>();

    // Internal tracking
    private class AgentPair
    {
        public Transform gtTransform;
        public AnchorClient_PDM vlaAgent;
        public GameObject vlaObject;
        public List<Vector3> gtPath = new List<Vector3>();
        public List<Vector3> vlaPath = new List<Vector3>();
        public Vector3 prevGtPos;
        public Vector3 lastGtVelocity;

        // Metrics per interval
        public float currentIntervalErrorSum = 0f;
        public int currentIntervalFrameCount = 0;
    }

    private Dictionary<int, AgentPair> pairs = new Dictionary<int, AgentPair>();

    // Metrics
    private List<float> allIntervalAverages = new List<float>(); // Mean error per interval
    private List<float> allFDEs = new List<float>(); // Final Displacement Error (At reset time)

    IEnumerator Start()
    {
        // Find Obstacles
        GameObject obsObj = GameObject.Find("Obstacles");
        if (obsObj != null)
        {
            obstaclesRoot = obsObj.transform;
            obstacleColliders = obstaclesRoot.GetComponentsInChildren<BoxCollider>().ToList();
            Debug.Log($"[PDMEvaluator] Found {obstacleColliders.Count} obstacle colliders.");
        }

        if (simulator == null) simulator = FindObjectOfType<ZaraGroupRotationSimulator>();

        // Wait for Simulator to spawn initial agents
        yield return null;

        // Initial scan
        ScanForNewAgents();

        Debug.Log($"[PDMEvaluator] Created {pairs.Count} pairs. Starting evaluation loop.");

        // Start the control loop
        StartCoroutine(EvaluationLoop());
    }

    void ScanForNewAgents()
    {
        // Find existing agents created by ZaraGroupRotationSimulator or others
        // Optimization: We could limit this scan frequency if needed
        GameObject[] allObjects = FindObjectsOfType<GameObject>();
        foreach (var go in allObjects)
        {
            if (go.name.StartsWith("ped_"))
            {
                if (int.TryParse(go.name.Substring(4), out int id))
                {
                    if (!pairs.ContainsKey(id))
                    {
                        CreatePair(id, go.transform);
                    }
                }
            }
        }
    }

    void CreatePair(int id, Transform gtTransform)
    {
        // Spawn VLA Agent at GT position
        GameObject vlaObj = Instantiate(vlaAgentPrefab, gtTransform.position, gtTransform.rotation);
        vlaObj.name = $"VLA_Agent_{id}";

        AnchorClient_PDM client = vlaObj.GetComponent<AnchorClient_PDM>();
        if (client == null)
        {
            Debug.LogError("VLA Agent Prefab missing AnchorClient_PDM component!");
            return;
        }

        client.manualControl = true; // Ensure manual control

        AgentPair pair = new AgentPair
        {
            gtTransform = gtTransform,
            vlaAgent = client,
            vlaObject = vlaObj,
            prevGtPos = gtTransform.position,
            currentIntervalErrorSum = 0f,
            currentIntervalFrameCount = 0
        };

        pairs.Add(id, pair);
    }

    IEnumerator EvaluationLoop()
    {
        // Initial delay to let everything settle
        yield return new WaitForSeconds(0.1f);

        while (true)
        {
            // Scan for new agents before every reset phase
            ScanForNewAgents();

            // --- 1. Reset Phase (Pause Time) ---
            Time.timeScale = 0f;

            int pendingRequests = 0;

            // Phase 1: Record Metrics & Reset All Agents Physically
            foreach (var pair in pairs.Values)
            {
                if (pair.gtTransform == null) continue;
                
                // If GT agent is inactive, disable VLA agent and skip
                if (!pair.gtTransform.gameObject.activeInHierarchy)
                {
                    if (pair.vlaObject.activeSelf) pair.vlaObject.SetActive(false);
                    continue;
                }
                
                if (!pair.vlaObject.activeSelf) pair.vlaObject.SetActive(true);

                // 1. Record Metrics (End of Interval)
                Vector3 gtPos = pair.gtTransform.position;
                Vector3 vlaPos = pair.vlaObject.transform.position;
                float dist = Vector3.Distance(new Vector3(gtPos.x, 0, gtPos.z), new Vector3(vlaPos.x, 0, vlaPos.z));

                // FDE: Distance at the very last moment
                if (pair.gtPath.Count > 1)
                {
                    allFDEs.Add(dist);
                }

                // ADE (Corrected): Calculate Average Error for THIS interval
                if (pair.currentIntervalFrameCount > 0)
                {
                    float intervalAvg = pair.currentIntervalErrorSum / pair.currentIntervalFrameCount;
                    allIntervalAverages.Add(intervalAvg);
                }

                // Reset sum for next interval
                pair.currentIntervalErrorSum = 0f;
                pair.currentIntervalFrameCount = 0;

                // Path Break for Visualization
                if (generateMap)
                {
                    pair.vlaPath.Add(Vector3.negativeInfinity);
                }

                // 2. Reset Agent State
                // Pass Vector3.zero for velocity as per requirements (time paused, wait for server)
                pair.vlaAgent.ForceReset(gtPos, pair.gtTransform.rotation, Vector3.zero);
            }

            // Phase 2: Request Batch (Capture & Predict) - Now that everyone is reset
            foreach (var pair in pairs.Values)
            {
                if (pair.gtTransform == null || !pair.gtTransform.gameObject.activeInHierarchy) continue;

                int agentId = int.Parse(pair.gtTransform.name.Replace("ped_", ""));
                Vector3 finalGoal = simulator.GetFinalWorldPosition(agentId);

                pendingRequests++;
                StartCoroutine(pair.vlaAgent.PrepareContinuousEvaluation(finalGoal, (success) =>
                {
                    pendingRequests--;
                }));
            }

            // --- 2. Wait for Requests ---
            float timeout = 10f; // Safety timeout
            float timer = 0f;
            while (pendingRequests > 0 && timer < timeout)
            {
                timer += Time.unscaledDeltaTime; // Use unscaled time
                yield return null;
            }

            if (timer >= timeout)
            {
                Debug.LogWarning("[PDMEvaluator] Timed out waiting for agents!");
            }

            // --- 3. Run Phase (Resume Time) ---
            Time.timeScale = 1f;

            // Start Playback for all ready agents
            foreach (var pair in pairs.Values)
            {
                if (pair.gtTransform != null && pair.gtTransform.gameObject.activeInHierarchy && pair.vlaObject.activeSelf)
                {
                    pair.vlaAgent.StartContinuousPlayback(resetInterval);
                }
            }

            // Wait for interval
            yield return new WaitForSeconds(resetInterval);
        }
    }

    void FixedUpdate()
    {
        if (pairs.Count == 0) return;

        foreach (var pair in pairs.Values)
        {
            if (pair.gtTransform == null) continue;

            bool gtActive = pair.gtTransform.gameObject.activeInHierarchy;
            Vector3 currentGtPos = pair.gtTransform.position;

            // Calculate velocity (Valid only when Time is running)
            if (Time.deltaTime > 1e-5f)
            {
                pair.lastGtVelocity = (currentGtPos - pair.prevGtPos) / Time.deltaTime;
            }

            if (pair.vlaObject.activeSelf != gtActive)
            {
                if (!gtActive && generateMap)
                {
                    RecordPath(pair.gtPath, currentGtPos);
                    if (pair.vlaObject != null)
                        RecordPath(pair.vlaPath, pair.vlaObject.transform.position);
                }

                pair.vlaObject.SetActive(gtActive);

                if (gtActive)
                {
                    // Reset on activation (Zero velocity)
                    pair.vlaAgent.ForceReset(currentGtPos, pair.gtTransform.rotation, Vector3.zero);
                    pair.currentIntervalErrorSum = 0f;
                    pair.currentIntervalFrameCount = 0;
                }
            }

            pair.prevGtPos = currentGtPos;

            if (!gtActive) continue;

            // --- Measure Frame Error & Accumulate ---
            Vector3 gtPos = currentGtPos;
            Vector3 vlaPos = pair.vlaObject.transform.position;

            float dist = Vector3.Distance(new Vector3(gtPos.x, 0, gtPos.z), new Vector3(vlaPos.x, 0, vlaPos.z));

            // Accumulate error for "ADE" metric
            pair.currentIntervalErrorSum += dist;
            pair.currentIntervalFrameCount++;

            if (generateMap)
            {
                RecordPath(pair.gtPath, gtPos);
                RecordPath(pair.vlaPath, vlaPos);
            }
        }
    }

    void RecordPath(List<Vector3> path, Vector3 currentPos)
    {
        Vector3 flatPos = new Vector3(currentPos.x, 0, currentPos.z);

        if (path.Count == 0)
        {
            path.Add(flatPos);
            return;
        }

        Vector3 lastPoint = path[path.Count - 1];

        if (float.IsNegativeInfinity(lastPoint.x))
        {
            path.Add(flatPos);
            return;
        }

        if (Vector3.Distance(lastPoint, flatPos) > 0.05f)
        {
            path.Add(flatPos);
        }
    }

    void OnApplicationQuit()
    {
        // ADE: Average of (Mean error per interval)
        if (allIntervalAverages.Count > 0)
        {
            Debug.Log($"[PDM Report] ADE (Average Displacement Error): {allIntervalAverages.Average():F4} meters (over {allIntervalAverages.Count} intervals)");
        }

        // FDE: Average of (Error at final frame of interval)
        if (allFDEs.Count > 0)
        {
            Debug.Log($"[PDM Report] FDE (Final Displacement Error): {allFDEs.Average():F4} meters (over {allFDEs.Count} intervals)");
        }

        if (generateMap)
        {
            GenerateMap();
        }
    }

    void GenerateMap()
    {
        Texture2D texture = new Texture2D(mapResolution, mapResolution);
        Color[] resetColor = new Color[mapResolution * mapResolution];
        for (int i = 0; i < resetColor.Length; i++) resetColor[i] = Color.white;
        texture.SetPixels(resetColor);

        float minX = transform.position.x - mapSize / 2f;
        float minZ = transform.position.z - mapSize / 2f;

        DrawColliders(texture, obstacleColliders, obstacleColor, minX, minZ);

        foreach (var pair in pairs.Values)
        {
            DrawPath(texture, pair.gtPath, gtColor, minX, minZ);
            DrawPath(texture, pair.vlaPath, vlaColor, minX, minZ);

            DrawEndPoint(texture, pair.gtPath, gtColor, minX, minZ);
            DrawEndPoint(texture, pair.vlaPath, vlaColor, minX, minZ);
        }

        texture.Apply();
        byte[] bytes = texture.EncodeToPNG();
        string path = Path.Combine(Application.dataPath, mapFileName);
        File.WriteAllBytes(path, bytes);
        Debug.Log($"PDM Map saved to {path} (Center: {transform.position.x}, {transform.position.z})");
    }

    // Drawing Helpers
    void DrawColliders(Texture2D texture, List<BoxCollider> colliders, Color color, float minX, float minZ)
    {
        foreach (var col in colliders)
        {
            if (col == null) continue;

            Transform t = col.transform;
            Vector3 center = col.center;
            Vector3 size = col.size;

            Vector3 p1 = t.TransformPoint(center + new Vector3(-size.x, -size.y, -size.z) * 0.5f);
            Vector3 p2 = t.TransformPoint(center + new Vector3(size.x, -size.y, -size.z) * 0.5f);
            Vector3 p3 = t.TransformPoint(center + new Vector3(size.x, -size.y, size.z) * 0.5f);
            Vector3 p4 = t.TransformPoint(center + new Vector3(-size.x, -size.y, size.z) * 0.5f);

            Vector2 px1 = WorldToPixel(p1, minX, minZ);
            Vector2 px2 = WorldToPixel(p2, minX, minZ);
            Vector2 px3 = WorldToPixel(p3, minX, minZ);
            Vector2 px4 = WorldToPixel(p4, minX, minZ);

            DrawLine(texture, px1, px2, color);
            DrawLine(texture, px2, px3, color);
            DrawLine(texture, px3, px4, color);
            DrawLine(texture, px4, px1, color);
        }
    }

    void DrawEndPoint(Texture2D tex, List<Vector3> path, Color col, float minX, float minZ)
    {
        if (path == null || path.Count == 0) return;

        Vector3 last = Vector3.negativeInfinity;
        for (int i = path.Count - 1; i >= 0; i--)
        {
            if (!float.IsNegativeInfinity(path[i].x))
            {
                last = path[i];
                break;
            }
        }

        if (!float.IsNegativeInfinity(last.x))
        {
            Vector2 pixel = WorldToPixel(last, minX, minZ);
            DrawCircle(tex, (int)pixel.x, (int)pixel.y, 5, col);
        }
    }

    void DrawPath(Texture2D tex, List<Vector3> path, Color col, float minX, float minZ)
    {
        if (path.Count < 2) return;

        Vector2 prev = Vector2.zero;
        bool hasPrev = false;

        for (int i = 0; i < path.Count; i++)
        {
            Vector3 pt = path[i];

            if (float.IsNegativeInfinity(pt.x))
            {
                hasPrev = false;
                continue;
            }

            Vector2 cur = WorldToPixel(pt, minX, minZ);

            if (hasPrev)
            {
                DrawLine(tex, prev, cur, col);
            }

            prev = cur;
            hasPrev = true;
        }
    }

    Vector2 WorldToPixel(Vector3 pos, float minX, float minZ)
    {
        float u = (pos.x - minX) / mapSize;
        float v = (pos.z - minZ) / mapSize;
        return new Vector2(u * (mapResolution - 1), v * (mapResolution - 1));
    }

    void DrawLine(Texture2D tex, Vector2 p1, Vector2 p2, Color col)
    {
        int x0 = (int)p1.x; int y0 = (int)p1.y;
        int x1 = (int)p2.x; int y1 = (int)p2.y;
        int dx = Mathf.Abs(x1 - x0), dy = Mathf.Abs(y1 - y0);
        int sx = x0 < x1 ? 1 : -1, sy = y0 < y1 ? 1 : -1;
        int err = dx - dy;
        while (true)
        {
            DrawBrush(tex, x0, y0, col);
            if (x0 == x1 && y0 == y1) break;
            int e2 = 2 * err;
            if (e2 > -dy) { err -= dy; x0 += sx; }
            if (e2 < dx) { err += dx; y0 += sy; }
        }
    }

    void DrawBrush(Texture2D tex, int x, int y, Color col)
    {
        int thickness = 3;
        int half = thickness / 2;
        for (int i = -half; i <= half; i++)
        {
            for (int j = -half; j <= half; j++)
            {
                if (x + i >= 0 && x + i < tex.width && y + j >= 0 && y + j < tex.height)
                {
                    tex.SetPixel(x + i, y + j, col);
                }
            }
        }
    }

    void DrawCircle(Texture2D tex, int cx, int cy, int r, Color col)
    {
        for (int x = -r; x <= r; x++)
        {
            for (int y = -r; y <= r; y++)
            {
                if (x * x + y * y <= r * r)
                {
                    int px = cx + x;
                    int py = cy + y;
                    if (px >= 0 && px < tex.width && py >= 0 && py < tex.height)
                        tex.SetPixel(px, py, col);
                }
            }
        }
    }
}